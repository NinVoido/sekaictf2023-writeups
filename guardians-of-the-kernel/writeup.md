## Guardians of the kernel - Reverse ☆☆

### Начало

В задаче нам даются два файла - initramfs.cpio.gz и bzImage, образы виртуального диска и ядра соответственно. Начнем реверсить;) Только вот что?

### А что реверсить-то?

Предлагаю начать с распаковки initramfs, сделать это можно так:
```bash
gunzip initramfs.cpio.gz
cpio -idv < initramfs.cpio
```
Сделав это, мы увидим знакомые папки:
```bash
ls
bin  etc  flag_checker.ko  home  init  linuxrc  ll  proc  root  sbin  sys  usr
```
Среди знакомых имен выступает одно - flag\_checker.ko. Как можно понять из расширения, это модуль ядра, который вероятно как-то проверяет флаг. Удостоверимся в этом!.
```bash
file flag_checker.ko
flag_checker.ko: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), BuildID[sha1]=3b4cfdadc8f5df6f70a4d6d5e68808192c3aa82e, with debug_info, not stripped
```
Давайте разбираться! Я буду использовать ghidra.

### Реверс

После анализа бинаря мы увидим несколько стандартных для модуля ядра функций, а так же несколько функций, только выводящих строки. Интерес для нас представляет device\_ioctl, вот как выглядит ее сигнатура: 
```c
undefined8 device_ioctl (undefined8 param_1, int param_2, undefined8 param_3);
```
Если мы посмотрим сигнатуру ioctl в man странице, увидим следующее:
```c
int ioctl(int fd, unsigned long request, ...);
 ```
 Ясно! Значит param_1 - fd, который, кстати, нигде не используется, param_2 - запрос, а param_3 - какая-то дополнительная информация... Посмотрим, где он используется:
 ```c
 iVar5 = _copy_from_user(buffer,param_3,7);
 lVar5 = _copy_from_user(buffer,param_3,0xc);
 lVar5 = _copy_from_user(buffer,param_3,6);
 ```
 Думаю, идея понятна даже тем, кто ранее не слышал о \_copy\_from\_user - param_3  это указатель на некий буффер в памяти пользователя, из которого, вероятно, мы и берем флаг для проверки.
 На всякий случай убедимся в этом, посмотря на сигнатуру \_copy\_from\_user:
 ```c
unsigned long __copy_from_user (void * to, const void __user * from, unsigned long n);
 ```
 
### Три уровня

Продолжим наше исследование. Заметим что есть всего три валидных запроса к ioctl - 0x7000, 0x7001, 0x7002. В каждом из них происходят похожие действия:
- от пользователя получается буффер
- с ним происходят некоторые действия
- результат действий как-то проверяется
- если проверка пройдена, выводится сообщение, что "уровень открылся", и соответствующее значение в массиве layer изменяется на 1

#### Уровень 1

Декомпилированный код:
```c
    lVar5 = _copy_from_user(buffer,param_3,6);
    if (lVar5 != 0) {
      return 0xfffffffffffffff2;
    }
    if ((buffer._0_4_ == 0x414b4553) && (CONCAT11(buffer[5],buffer[4]) == 0x7b49)) {
      printk(&DAT_001002f6);
      layers[1] = 1;
      return 1;
    }
```

- ! В коде присутствуют некоторые нотации, специфичные для Ghidra !
- - `arr._a_b_` когда a < b - срез массива от a до b (`arr[a:b]` в python)
- - `arr._a_b_` когда a > b - срез массива от a до b в обратном порядке (`arr[a:b:-1]` в python)
- - `CONCAT{A}{B}(buf1, buf2)` - конкатенация одного буффера из A байт и второго из B байт

В первом if проверяется, успешно ли скопировался буффер пользователя - в дальнейшем эту конструкцию я буду опускать. Нам интересен второй if - в нем есть два условия, оба должны выполняться. Разберем их.

1) `(buffer._0_4_ == 0x414b4553)`. Проверка первых четырех элементов на совпадение с некоторым числом. Посмотрим, как оно представляется в строковом формате:
```python
>>> bytes.fromhex("414b4553")
b'AKES'
```
Нетрудно догадаться, что это часть начала флага (SEKAI)

2) `(CONCAT11(buffer[5],buffer[4]) == 0x7b49)` Поступим так же:
```python
>>> bytes.fromhex("7b49")
b'{I'
```
Значит, 6 элемент флага равен {, а пятый - I. Пока все по формату!

#### Уровень 2

Сдекомпилированный код:
```c
      lVar5 = _copy_from_user(buffer,param_3,7);
      if (lVar5 != 0) {
        return 0xfffffffffffffff2;
      }
      buffer[7] = '\0';
      puVar3 = buffer;
      do {
        if (9 < (byte)(*puVar3 - 0x30)) {
          buffer[7] = '\0';
          return 0;
        }
        puVar3 = puVar3 + 1;
      } while (puVar3 != buffer + 7);
      uVar1 = (uint)(buffer._0_4_ * 0x193482ba) >> 0xf |  buffer._0_4_ * 0x5740000;
      uVar2 = (uint)buffer[4] ^ (uint)buffer[6] << 0x10 ^ ( uint)buffer[5] << 8;
      uVar1 = (uVar2 * 0x193482ba >> 0xf | uVar2 * 0x5 740000) * 0x59d87c3f ^
              (uVar1 * -0x3c1e0800 | uVar1 * 0x59d87c3f > > 0x15) * 7 + 0x47c8ac62;
      uVar1 = (uVar1 >> 0x10 ^ uVar1 ^ 7) * 0x764521f9;
      uVar1 = (uVar1 ^ uVar1 >> 0xd) * -0x6c53e18a;
      if ((uVar1 ^ uVar1 >> 0x10) == 0xf99c821) {
        uVar4 = device_ioctl.cold();
        return uVar4;
      }
```
Длина проверяемой части флага - 7 байт. Первым делом мы нуль-терминируем буффер. Далее в цикле идет следующая проверка:
```c
if (9 < (byte)(*puVar3 - 0x30)) {
          buffer[7] = '\0';
          return 0;
 }
```
Если значение символа строки - 0x30 превышает 9, функция прерывается - флаг неверный. Тогда максимальное значения символа в строчке будет равно 0x39, то есть '9'. Если обратиться к формату флага, можно понять, что в таком случае единственные допустимые символы в строке будут цифры от 0 до 9. Запомним это.\
Далее идут много сложных преобразований и финальная проверка. Можно конечно попытаться распутать эту цепь, но поскольку в строке могут встречаться лишь лишь 7 символов, и на каждой позиции может стоять 10 возможных значений, всего возможно 10^7 комбинаций флага, что легко перебирается. Для легкости, я решил писать брутер на C, скопировав код проверки из Ghidra:
```c
#include <stdio.h>

#define uint unsigned int

_Bool test(char* buffer) {
      uint uVar1 = (uint)(*(uint*)buffer * 0x193482ba) >> 0xf |  *(uint*)buffer * 0x5740000;
      uint uVar2 = (uint)buffer[4] ^ (uint)buffer[6] << 0x10 ^ ( uint)buffer[5] << 8;
      uVar1 = (uVar2 * 0x193482ba >> 0xf | uVar2 * 0x5740000) * 0x59d87c3f ^
              (uVar1 * -0x3c1e0800 | uVar1 * 0x59d87c3f >> 0x15) * 7 + 0x47c8ac62;
      uVar1 = (uVar1 >> 0x10 ^ uVar1 ^ 7) * 0x764521f9;
      uVar1 = (uVar1 ^ uVar1 >> 0xd) * -0x6c53e18a;
      if ((uVar1 ^ uVar1 >> 0x10) == 0xf99c821) {
        return 1;
      }
      return 0;
}

int main() {
  for (char a = '0'; a <= '9'; ++a) {
  for (char b = '0'; b <= '9'; ++b) {
  for (char c = '0'; c <= '9'; ++c) {
  for (char d = '0'; d <= '9'; ++d) {
  for (char e = '0'; e <= '9'; ++e) {
  for (char f = '0'; f <= '9'; ++f) {
  for (char g = '0'; g <= '9'; ++g) {
    char buf[8] = {a, b, c, d, e, f, g, 0};
    if (test(buf)) {
      printf("%s\n", buf);
      return 0;
    }
  }
  }
  }
  }
  }
  }
  }
}
```
Запустив код, получим ответ - "6001337". Второй уровень пройден!

#### Уровень 3

Код:
```c
      lVar5 = _copy_from_user(buffer,param_3,0xc);
      if (lVar5 != 0) {
        return 0xfffffffffffffff2;
      }
      do {
        buffer[lVar5] = buffer[lVar5] + ~(byte)lVar5 * buffer[lVar5 + 1];
        lVar5 = lVar5 + 1;
      } while (lVar5 != 0xc);
      if (((CONCAT17(buffer[7], CONCAT16(buffer[6], CONCAT15(buffer[5], CONCAT14(buffer[4],buffer._0_4_)))) == 0x788c88b91d88af0e) && (buffer._8_4_ == 0x7df311ec)) && (buffer[12] == '\0')) {
        printk(&DAT_0010032b);
        return 1;
      }
```

От пользователя мы получаем целых 12 байт! Посмотрим, что с ними происходит.\
Сначала все байты, кроме последнего преобразуются с учетом следующего байта и их позиции:
```c
      do {
        buffer[lVar5] = buffer[lVar5] + ~(byte)lVar5 * buffer[lVar5 + 1];
        lVar5 = lVar5 + 1;
      } while (lVar5 != 0xc);
```
Далее идет проверка уже обработанных байт.
1) `(buffer[12] == '\0')` - проверка, что буффер нуль-терминирован
2) `(buffer._8_4_ == 0x7df311ec)` - получим байты уже известным нам образом:
```python
>>> bytes.fromhex("7df311ec")
b'}\xf3\x11\xec'
```
Обратите внимание, что в итоговом буффере порядок байт будет обратным. Так же последний символ будет }, что идет соответствует формату флага;)
3) `((CONCAT17(buffer[7], CONCAT16(buffer[6], CONCAT15(buffer[5], CONCAT14(buffer[4],buffer._0_4_)))) == 0x788c88b91d88af0e)` - пожалуй, самое страшное. Однако, зная CONCAT-запись все понятно - старшему байту числа соответствует восьмой элемент буффера, второму - седьмой, третьему - шестой, четвертому - пятый, а далее байты с 1 по 4 идут по порядку. Получим байты уже известным способом:
```python
>>> bytes.fromhex("788c88b91d88af0e")
b'x\x8c\x88\xb9\x1d\x88\xaf\x0e'
```
Теперь, имея байты получившегося буффера, ничего не стоит обратить изменения. Для того, чтобы битовые операции точно сработали как задумано, я использовал C.
```c
#include <stdint.h>
#include <stdio.h>

#define byte uint8_t

int main() {
  char buffer[13] = {'\x0e', '\xaf', '\x88', '\x1d', '\xb9', '\x88', '\x8c', '\x78', '\xec', '\x11', '\xf3', '\x7d', 0};

  for (long i = 11; i > -1; --i) {
    buffer[i] -= ~(byte)i * buffer[i + 1];
  }

  printf("%s\n", buffer);
}
```
Запустим, получим последнюю часть флага - "SEKAIPL@YER}".

### Флаг
SEKAI{6001337SEKAIPL@YER}
